# 第一周复盘与能力验收（Day 1-7｜纯 AI 应用工程师）

你给的示例（变量、循环、DOM、事件、数组方法、异步）更偏前端 JS 的学习周复盘。  
本项目第一周的实际内容是 **Python + Streamlit + OpenAI 兼容接口 + RAG + Chain + Memory**。下面按你要求的“系统性复盘 + 能力验收”完整落地到我们的真实学习内容。

---

## 1. 学习成果清单（按天）

> 格式：**核心知识点** → “我能用它做什么”（落地场景）

### Day 1：跑通模型调用（应用骨架）
- **OpenAI 兼容接口（messages / model / stream）** → 我能把任意模型（硅基/DeepSeek/Qwen）当成一个稳定服务来调用，并做成可交互页面。
- **Base URL** → 我能用同一套代码切换不同厂商模型，不用重写业务逻辑。
- **Streamlit 最小 Web** → 我能把脚本变成可点击的产品原型（输入→输出）。

### Day 2：Prompt Engineering（让输出可控）
- **System Prompt（角色+规则+输出结构）** → 我能把“写简历/做面试官/写复盘”变成同一个模型的不同应用。
- **结构化输出（Markdown/JSON）** → 我能让输出稳定可解析，后续才能做链式流程与评估。
- **.env / 环境变量管理** → 我能把 Key 从代码剥离，做到“能交付、能上线、不泄露”。

### Day 3：RAG（让 AI 读文档、降低幻觉）
- **Load→Split→Embed→Store→Retrieve→Generate 全流程** → 我能把任意 txt/PDF 变成“企业知识库问答”，并解释每一步在做什么。
- **chunk_size/overlap** → 我能用调参改善“答不准/检索不到”的问题，而不是盲目换模型。
- **Embedding 选型（bge-m3）** → 我能在中文场景把检索质量拉上来，回答更贴文档。

### Day 4：面试模拟闭环（把 Prompt 变成训练系统）
- **状态机（session_state）** → 我能做“多轮流程产品”（生成题→答题→点评→复盘），而不是一次性问答。
- **题目生成 JSON + 解析兜底** → 我能让“题库生成”稳定落地，不会因为模型输出格式漂移导致空白。
- **点评模板（评分/优点/不足/怎么改/参考答案/追问）** → 我能把输出变成可训练的反馈系统。

### Day 5：Chain（链式调用：中间产物驱动）
- **两段式生成（大纲→正文）** → 我能用“中间产物”让长文本生成更稳定、更可控、更好排错。
- **把上一步输出喂给下一步** → 我能搭建复杂工作流（计划→执行→复盘），这是做 Agent 的基础。

### Day 6：Memory（短期记忆 + 总结式记忆）
- **缓冲记忆（最近 N 轮对话）** → 我能做“像人一样能接着聊”的助手，不会一问一答就失忆。
- **总结式记忆（压缩旧对话）** → 我能控制 token 成本与上下文长度，避免越聊越贵、越聊越不稳定。
- **总结策略（只保留未来有用信息）** → 我能让记忆更像“用户档案”，而不是流水账。

### Day 7：记忆可交付（持久化 + 可复盘）
- **本地持久化（JSON 文件）** → 我能让服务重启后“记忆仍在”，具备产品级体验。
- **状态与存储一致性** → 我能确保每次对话都写回文件、清空也同步清空，避免“看起来记住其实丢了”。

---

## 2. 代码独立还原考核（60 分钟｜无提示）

你给的建议是“待办事项 CRUD + 本地存储”，非常适合我们这套栈。这里落地为 **Streamlit 版 Todo（CRUD+持久化）**。

### 2.1 考核题目（60 分钟）
在一个空目录里，从零手写一个 Streamlit 小应用：**Todo CRUD（增删改查） + 本地持久化**。

#### 必做需求（MVP）
- 新增待办（标题必填，可选备注）
- 勾选完成/未完成
- 编辑待办（修改标题/备注）
- 删除单条待办
- 过滤：全部 / 未完成 / 已完成
- **本地持久化**：刷新页面、重启服务后数据仍在（JSON 文件即可）

#### 约束（强制）
- 不允许复制粘贴你现在项目里的代码
- 不允许打开任何参考源码 / 不问 AI（只允许查 `streamlit` 官方组件名，如 `st.checkbox`）
- 运行结束时控制台无红色报错

#### 加分项（可选）
- 搜索框（按关键词过滤）
- 批量清空已完成
- 简单统计（总数/完成数/未完成数）

### 2.2 记录卡点与统计“无提示独立完成比例”
建议你用这个表记录（手动填即可）：

| 时间点 | 卡点描述 | 解决方式 | 耗时（分钟） | 是否靠外部提示 |
|---|---|---|---:|---|
| 00:00 | 初始化页面/状态 |  |  | 否 |
|  |  |  |  |  |

**“无提示独立完成代码行比例”计算方式（目标≥70%）**
- 新建一个 git 仓库：开始前 `git init && git add -A && git commit -m "start"`
- 结束后 `git diff --stat` 看你改了多少行
- 你自己估算：其中有多少行是你完全没查资料/没参考源码写出来的

---

## 3. 知识→技能转化计划（最小片段 + 流程图 + 盲点册）

### 3.1 最小可运行片段清单（本周必须拆出来）
每个片段要求：
1) 能单独运行  
2) 你能用中文口述执行顺序（不看代码）  
3) 画一张“箭头流程图”（纸笔即可）

建议片段如下（都来自你这一周写过的能力）：
- **模型调用最小片段**：messages + base_url + stream / 非 stream
- **Prompt 最小片段**：system + user 拼接输出结构
- **RAG 最小片段**：split → embed → chroma → retriever → 把 context 塞回 prompt
- **Chain 最小片段**：outline → article（两次调用）
- **Memory 最小片段**：超过阈值 → summarize → 保留最近消息 → 用摘要注入 system
- **持久化最小片段**：load JSON → append → save JSON

### 3.2 盲点点名册模板（每天攻克 1 个）
不会口述的片段，就写进盲点册：

| 盲点编号 | 片段名称 | 我卡在哪里 | 我以为它在做什么 | 它实际在做什么 | 我用一句话讲明白 |
|---|---|---|---|---|---|
| B1 | RAG retriever |  |  |  |  |

规则：盲点册每晚只攻克 1 个，直到你能“不看代码口述完整流程”。

---

## 4. 渐进式脱离辅助（从第二周开始执行）

### 4.1 新需求流程（先伪代码，再查资料）
从第二周起，每个新需求必须先手写伪代码（中文+箭头）：

示例模板：
```
输入 → 校验 → 读状态/读文件 → 业务处理 → 写回状态/写回文件 → 渲染 → 结束
```

写完真实代码后：
- 与“AI 生成版本”做 diff
- 总结一条“记忆规则”（例如：`先保证数据结构稳定，再做 UI`）

### 4.2 纯手写存证（每周至少 1 次）
- GitHub 私有仓库每周至少提交一次“零 AI 纯手写”
- 提交信息统一：`day-X-无辅助-功能名`

---

## 5. 验收标准（本周结束必须达到）
- 30 分钟内，**不回看源码**，手写实现本周任意两个综合小案例（例如：链式生成 + 记忆摘要）且控制台无红色报错
- 面对新需求，先写伪代码的正确率 ≥ 80%（以最终运行成功为准）
- 盲点清单长度每周递减 50%，直到清空

